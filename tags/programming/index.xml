<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on Cognition Limits Imagination</title>
    <link>/tags/programming/</link>
    <description>Recent content in Programming on Cognition Limits Imagination</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 13 Nov 2022 13:38:29 +0800</lastBuildDate><atom:link href="/tags/programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Design Pattern - Command (2)</title>
      <link>/posts/design-pattern-command-2/</link>
      <pubDate>Sun, 13 Nov 2022 13:38:29 +0800</pubDate>
      
      <guid>/posts/design-pattern-command-2/</guid>
      <description>我目前理解設計模式（design pattern）存在目的是為了讓軟體分層，使得每個物件提供盡可能單一的功能。這樣設計的好處是只要物件提供單一功能，那麼該物件更易於維護，減少變更的機會。
一般來說採用設計模式能讓軟體設計更有彈性、易於維護，但我覺得不是所有程式碼都需要考慮到設計模式，如果一段程式碼寫好之後便再也不需要變動（不會再有新的需求，不需要再維護），那麼用什麼樣的方式實現其實影嚮不大。
更深一層思考，需求變動通常意味著程式碼變動，如果只是一味的透過增加 function 參數、用 if 去判斷情境，程式碼的複雜度會不斷提高，演化到極致所有程式碼會有「牽一髮而動全身」的特性，讓人難以修改也難以維護。所以某種程度來說，設計模式存在的原因是為了讓程式複雜度處在人能接受的範圍。換句話說，如果有一天電腦能設計出軟體，那麼設計模式對於電腦來說是不必要的，因為電腦有盡乎無窮的算力因此處理複雜度的能力遠高於人類。
隨著商業變動而讓程式碼需要提供更多不同、更複雜的功能 ，低耦合（couple）的設計可以減少維護成本、減少 bug 出現的機率、提高可讀性。
接續前面小吃攤例子，每當攤販新增一種商品也同時需要服務員、顧客的溝通做修改，那這樣的設設違反 single responsibility 原則，因為修改物件（攤販、服務員、顧客）原因來自於跟物件本身功能無關。
接下來再一一拆解顧客與服務員的關係，為什麼顧客需要知道小吃攤點飯時需要加蛋的選項？吃飯加蛋這更像是服務員跟攤販之前的關係。也就是說，顧客與服務員只要能溝通（講國語、講英語），那麼服務員就有辦法知道顧客需要什麼。
接下來是服務員與攤販之類的關係，服務員只要把顧客的訂單通知攤販即可，不同的訂單可能會有不同的參數，而不同訂單的參數屬於各自的 private 資料，並不需要洩露。
當攤販新增了咖哩飯的餐點時，只需要新增一個 class 便能達成：
當服務員新增一種語言時，只要修改 Language 介面極可：
如果以 c++ 實作的話會像是這樣：
class Language { public: virtual void English() { std::cout &amp;lt;&amp;lt; &amp;#34;Cannot speak english&amp;#34; &amp;lt;&amp;lt; std::endl } virtual void Chiniese() { std::cout &amp;lt;&amp;lt; &amp;#34;不會講中文&amp;#34; &amp;lt;&amp;lt; std::endl } }; class ChineseCustomer : public Language { public: void Chinese() override { std::cout &amp;lt;&amp;lt; &amp;#34;來份飯&amp;#34; &amp;lt;&amp;lt; std::endl; } }; class EnglishCustomer : public Language { public: void English() override { std::cout &amp;lt;&amp;lt; &amp;#34;A Noodle&amp;#34; &amp;lt;&amp;lt; std::endl; } }; class Order { public: virtual void Details() = 0; }; class FoodOrder : public Order { public: FoodOrder(bool egg) : egg_(egg) {} void Details() override { std::cout &amp;lt;&amp;lt; &amp;#34;一碗白飯、蛋 &amp;#34; &amp;lt;&amp;lt; egg_ &amp;lt;&amp;lt; std::endl; } private: bool egg_ = false; }; class NoodleOrder : public Order { public: NoodleOrder(bool soup) : soup_(soup) {} void Details() override { std::cout &amp;lt;&amp;lt; &amp;#34;一份麵，湯 &amp;#34; &amp;lt;&amp;lt; soup_ &amp;lt;&amp;lt; endl; } private: boo soup_ = false; }; class Waiter : public Language { public: void Chinese() { std::cout &amp;lt;&amp;lt; &amp;#34;歡迎光臨&amp;#34; &amp;lt;&amp;lt; std::end; } void English() { std::cout &amp;lt;&amp;lt; &amp;#34;Welcome&amp;#34; &amp;lt;&amp;lt; std::end; } Order GenerateOrder() {} }; class FoodStaller { public: FoodStaller() {} void TakeOrder(const Order&amp;amp; order) { std::cout &amp;lt;&amp;lt; order.</description>
    </item>
    
    <item>
      <title>Design Pattern - Command (1)</title>
      <link>/posts/design-pattern-command-1/</link>
      <pubDate>Sun, 06 Nov 2022 23:11:07 +0800</pubDate>
      
      <guid>/posts/design-pattern-command-1/</guid>
      <description>想像一個常見的場景：一位顧客走到小吃攤前點了一份小吃，以 class diagram 表示會像是下面這樣：
簡單的情境隱含著一些限制：小吃攤要正好有空、顧客要先排隊、兩者講同樣的語言、先點餐後付錢還是先付錢後取餐、如果修改訂單攤販要記得之前點了什麼…。 這樣模式在人不多時候還行的通，但如果要有效溝通或是人一旦多起來，需要把顧客與攤販的緊密耦合(couple)解耦(decouple)，這時候會需要額外一位服務員做準備餐點之外的工作，像下樣這樣：
顧客與攤販間多了位服務員，把顧客與攤販的關系解耦：
如果顧客講英語，服務員可以聽了英語再把訂單轉換成國語 服務員可以在紙上記下每位顧客的訂單，照著順序發給老闆 服務員可以在點餐/取餐時收取費用 上面的例子，把顧客-服務員-攤販的關系寫的很固定，如果服務員要離職，攤販想要找另一位服務員，提出的要求會是要同時能說英文與中文，只要任何服務員可以說英文與中文便可以應徵。這個時候，會說中文與英文便是一種 interface ：
雖然每個物件依賴於 interface ，但還會有個問題，如果今天攤販在點飯的時候除了可以選擇飯量之外，還可以選要不要加滷汁，這時候會同時需要修改 WaiterIntf ， CustomerIntf ，與 FoodStallerIntf 。物件之間的關係依然是緊緊的耦合，因為顧客、服務員、攤販需要提供一致的溝通。
有沒有可能顧客是巷口大媽，一開始就講：今天人好多，生意不錯喔！？你們家的麵怎麼樣？會不會辣？啊，不行，今天好像有點餓，還是吃點飯？會不會吃不飽啊，有沒有其它能選…
攤販肯定是不需要這段話，而是需要服務員溝通過後轉譯的訂單，這樣的情況意味著顧客下單時說的長篇大論攤販不會也不需要知道，攤販只需要顧客需要真正的東西（訂單）是什麼。
另一個問題是，單純把 API 轉成 interface 是好的作法嗎？怎麼感覺物件間的耦合還是很嚴重？這些問題會在下一篇討論。</description>
    </item>
    
    <item>
      <title>Design Pattern Command</title>
      <link>/images-in-content/design-pattern-command/</link>
      <pubDate>Sun, 06 Nov 2022 21:58:37 +0800</pubDate>
      
      <guid>/images-in-content/design-pattern-command/</guid>
      <description>Design Pattern - Command 想像一個常見的場景：一位顧客走到小吃攤販前點了一份小吃。以 class diagram 表示會像是下面這個樣子：
Imageine a common scenario:</description>
    </item>
    
    <item>
      <title>Dropbox Engineer Ladder</title>
      <link>/posts/dropbox-engineer-ladder/</link>
      <pubDate>Fri, 16 Jul 2021 23:14:09 +0800</pubDate>
      
      <guid>/posts/dropbox-engineer-ladder/</guid>
      <description>最近 Dropbox 發布了 engineer ladder
從 software engineer 到 quality assurance engineer，再到 reliability engineer，不同層級有著不同的標準。
大公司有著明確制度，想要往上爬就需要滿足特定條件，一方面是學習，另一方面也是挑戰，能不能上去還是看個人。
公司內部也有相對應文件，我想，先定好目標，比較知道缺失什麼需要補強。</description>
    </item>
    
    <item>
      <title>One and Half Year</title>
      <link>/posts/one-and-half-year/</link>
      <pubDate>Tue, 29 Jun 2021 19:53:14 +0800</pubDate>
      
      <guid>/posts/one-and-half-year/</guid>
      <description>不知不覺，刷題一年半了，從一開始的好奇到有點厭煩，如今習以為常。
有段時間非常在意效率，今天寫了幾題各花了多少時間；有段時間比較怠惰，時間一到就休息。
過去的記憶開始模糊，這一年半好像很累，但又好像轉瞬即逝，最後定格的，是某次上班超累，下班完坐在星巴克，頭痛愈裂，想寫題目卻想不出任何解法。
細節已經不太清楚，只記得那個感覺…只記得努力。
我想，人還是低調、謙虛點，能走的比較遠吧。</description>
    </item>
    
    <item>
      <title>Bus Factor</title>
      <link>/posts/bus-factor/</link>
      <pubDate>Sun, 27 Jun 2021 18:40:21 +0800</pubDate>
      
      <guid>/posts/bus-factor/</guid>
      <description>The number of people that need to get hit by a bus before your project is completely doomed.
這個指標橫量多少人熟悉專案，直觀上來說如果只有原作者了解專案，那麼專案就愈容易受到個人影嚮；了解的人愈多代表專案相關的知識愈被廣泛熟知。有趣的是，書中提到這個概念並不是在 knowledge sharing 相關章節，而是在鼓勵多與人互動的章節。
大部份人的天性是希望等到程式碼寫到完美後再發佈，但只有一個人知道的專案除了容易後繼無人外，缺乏討論、溝通的專案很可能在設計初期就埋藏了不可彌補的錯誤。
常見的 Documentation，Pair pairgramming，Code review 都可以避免知識只存在少數人腦中的情況。</description>
    </item>
    
    <item>
      <title>Leetcode 795</title>
      <link>/posts/leetcode-795/</link>
      <pubDate>Sun, 20 Jun 2021 14:12:16 +0800</pubDate>
      
      <guid>/posts/leetcode-795/</guid>
      <description>Program description at here
Although I know this problem can be solved in linear time, it still takes me a while to fiture out the optimal solution.
Taking an example of array [1, 2, 1, 3, 1, 4], maximum range from 2 ~ 3.
[1, 2, 1, 3, 1, 4] ^ start from here, 1 &amp;lt; 2 not in range, total 4 sub-arrays meet criteria: [1, 2], [1, 2, 1], [1, 2, 1, 3], [1, 2, 1, 3, 1] ^ start from here, 2 &amp;gt;= 2 &amp;amp;&amp;amp; 2 &amp;lt;= 3 in range, total 4 sub-arrays meet criteria: [2], [2, 1], [2, 1, 3], [2, 1, 3, 1] ^ start from here, 1 &amp;lt; 2, not in range, total 2 sub-arrays meet criteria: [1, 3], [1, 3, 1] ^ start from here, 3 &amp;gt;= 2 &amp;amp;&amp;amp; 3 &amp;lt;= 3 in range, total 2 sub-arrays meet criteria: [3], [3, 1] ^ start from here, 1 &amp;lt; 2 not in range, total 0 sub-arrays meet criteria It&amp;rsquo;s obvious to check valid sub-arrays start from specific index, this way guarantees no duplicate count exists.</description>
    </item>
    
    <item>
      <title>Hyrum&#39;s Law</title>
      <link>/posts/hyrum-law/</link>
      <pubDate>Wed, 16 Jun 2021 21:58:12 +0800</pubDate>
      
      <guid>/posts/hyrum-law/</guid>
      <description>這章在講 scalability，裡面提到一個概念 Hyrum&amp;rsquo;s Law (Hyrum 是 Google 工程師):
With a sufficient number of users of an API, it does not matter what you promise in the contract: all observable behaviors of your system will be depended on by somebody.
這段話大意是任何提供給外部系統的 API，不論文件上如何寫，任何可被觀測的行為最終都會被某種方式所依賴。有點繞口，書上舉的例子是 hash table，幾乎所有工程師都知道 hash table 內儲存物件的順序是不固定的，所以程式執行不該依賴於 hash table 所提供的順序。
我在這部影片中聽到原作者的另一個例子：在某個 c++ 的 header file 裡面加了一行註解，導致測試壞掉……how could that happen? 原來是有人把測試寫死在程式執行到第幾行的時候，所以新增註解導致錯誤。
愈多人使用 API 代表提供愈高的價值，但因為愈多人使用也促使這隻 API 的 dependency 愈高，反而阻止了 API 更新。
依賴無處不在</description>
    </item>
    
    <item>
      <title>Leetcode 1552 (2)</title>
      <link>/posts/leetcode-1552-2/</link>
      <pubDate>Tue, 25 Aug 2020 20:25:19 +0800</pubDate>
      
      <guid>/posts/leetcode-1552-2/</guid>
      <description>This article tries to write down some notes while trying to solve problem 1552.
After some days of thinking, I finally understand why this is a binary search problem.
Thinking Didn&amp;rsquo;t think of binary search because I miss some details about this problem:
To get maximum of minimum distance among selected numbers, smallest &amp;amp; largest numbers will definited being selected, because choosing them provides maximum range to distribute distance. Once smallest &amp;amp; largest numbers are selected, theoretically maximum distance could be upper bounded to (largest - smallest) / (selected - 1)</description>
    </item>
    
    <item>
      <title>Leetcode 1552 (1)</title>
      <link>/posts/leetcode-1552-1/</link>
      <pubDate>Fri, 21 Aug 2020 20:19:13 +0800</pubDate>
      
      <guid>/posts/leetcode-1552-1/</guid>
      <description>This article tries to write down some notes while trying to solve problem 1552.
I think this problem can be restated as follows: given some positive integers with total size n, pick m numbers such that minimum distance among each selected is maximum.
When first see this problem, I think it&amp;rsquo;s a knapsack problem: every number will be selected or not, find those possible combinations (pick m from n), calculate minimum distance, choose maximum from them.</description>
    </item>
    
  </channel>
</rss>
